[{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/capacitor.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/BackgroundPattern.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/Layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/Logo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/MainLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ProtectedRoute.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/QuoteOfTheDay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ThemeToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/accordion.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/alert-dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/aspect-ratio.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/breadcrumb.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/carousel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/chart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/collapsible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/command.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/context-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/drawer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/dropdown-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/hover-card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/input-otp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/menubar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/navigation-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/pagination.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/radio-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/resizable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/separator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/sheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/sonner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/table.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/toast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/toaster.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/toggle-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/toggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/components/ui/use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/contexts/AuthContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[428,431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[428,431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[587,590],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[587,590],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[798,801],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[798,801],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[817,820],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[817,820],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[846,849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[846,849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[962,965],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[962,965],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[991,994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[991,994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1723,1726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1723,1726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":356,"column":16,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":356,"endColumn":22},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":357,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":357,"endColumn":28},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":377,"column":16,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":377,"endColumn":22},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":378,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":378,"endColumn":28}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { getSupabaseClient } from '@/lib/supabase';\nimport { AuthError, Session, User } from '@supabase/supabase-js';\nimport type { Session as TypeSession, User as TypeUser } from '@supabase/supabase-js';\n\n// Define types for the user profile\ninterface UserProfile {\n  id: string;\n  created_at?: string;\n  updated_at?: string;\n  email?: string;\n  name?: string;\n  role?: string;\n  [key: string]: any;\n}\n\n// Define the shape of the context value\ninterface AuthContextType {\n  session: TypeSession | null;\n  user: TypeUser | null;\n  profile: Record<string, any> | null; // Or define a specific Profile type\n  loading: boolean; // Combined loading state\n  authError: AuthError | null;\n  signIn: (credentials: {\n    email?: string;\n    password?: string;\n    provider?: any;\n    options?: any;\n  }) => Promise<{ data: any; error: AuthError | null }>;\n  signUp: (credentials: {\n    email?: string;\n    password?: string;\n    options?: any;\n  }) => Promise<{ data: any; error: AuthError | null }>;\n  signOut: () => Promise<void>;\n  updateProfile?: (\n    updates: Partial<UserProfile>\n  ) => Promise<{ data?: UserProfile | null; error: Error | null }>;\n}\n\n// Create the context with an explicit type (or null initially)\nconst AuthContext = React.createContext<AuthContextType | null>(null);\n\n// Define props for the provider\ninterface AuthProviderProps {\n  children: React.ReactNode;\n}\n\n// Create the provider component\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [session, setSession] = React.useState<TypeSession | null>(null);\n  const [user, setUser] = React.useState<TypeUser | null>(null);\n  const [profile, setProfile] = React.useState<Record<string, any> | null>(null); // To store role, name, etc.\n  const [loadingSession, setLoadingSession] = React.useState<boolean>(true); // Loading state for session check\n  const [loadingProfile, setLoadingProfile] = React.useState<boolean>(false); // Loading state for profile fetch\n  const [authError, setAuthError] = React.useState<AuthError | null>(null); // Add state for auth errors\n  const [isUpdatingProfile, setIsUpdatingProfile] = React.useState<boolean>(false);\n\n  // Add a ref to track ongoing profile fetch requests\n  const profileFetchInProgress = React.useRef<string | null>(null);\n\n  // Add refs to track session initialization state\n  const isInitialized = React.useRef<boolean>(false);\n  const initializedUser = React.useRef<string | null>(null);\n\n  // Reset error state after 5 seconds\n  React.useEffect(() => {\n    if (authError) {\n      const timer = setTimeout(() => {\n        setAuthError(null);\n      }, 5000);\n\n      return () => {\n        clearTimeout(timer);\n      };\n    }\n  }, [authError]);\n\n  // Effect for initializing session and setting up listener\n  React.useEffect(() => {\n    let ignore = false;\n    console.log('[AuthContext] Session Effect mounting...');\n    setLoadingSession(true);\n    setAuthError(null);\n\n    async function getInitialSession() {\n      console.log('[AuthContext] Attempting to get initial session...');\n      try {\n        // Use the appropriate client based on availability\n        const client = getSupabaseClient();\n\n        // Fetch session with error handling\n        const {\n          data: { session },\n          error,\n        } = await client.auth.getSession();\n\n        if (error) {\n          console.error('[AuthContext] Error getting initial session:', error.message);\n          if (ignore) return;\n          setAuthError(error);\n        }\n\n        // Update session if component is still mounted\n        if (ignore) return;\n        console.log('[AuthContext] Initial session fetched:', session ? 'Exists' : 'null');\n\n        // Set initial session and user, profile fetch handled by separate effect\n        setSession(session);\n\n        // Only update user state if it's different to avoid triggering unnecessary effects\n        const newUser = session?.user ?? null;\n        if (newUser?.id !== initializedUser.current) {\n          setUser(newUser);\n          if (newUser) {\n            initializedUser.current = newUser.id;\n          } else {\n            initializedUser.current = null;\n          }\n        }\n\n        isInitialized.current = true;\n      } catch (err) {\n        console.error('[AuthContext] Error in getInitialSession catch block:', err);\n        if (!ignore) setAuthError(err instanceof AuthError ? err : null);\n      } finally {\n        console.log(\n          '[AuthContext] Initial Session: >>> Reached finally block. Attempting setLoadingSession(false).'\n        );\n        if (!ignore) setLoadingSession(false);\n        console.log('[AuthContext] Initial Session: <<< setLoadingSession(false) executed.');\n      }\n    }\n\n    getInitialSession();\n\n    console.log('[AuthContext] Setting up onAuthStateChange listener...');\n    const {\n      data: { subscription },\n    } = getSupabaseClient().auth.onAuthStateChange((_event, session) => {\n      if (ignore) return; // Prevent updates after unmount\n      console.log(\n        '[AuthContext] onAuthStateChange triggered. Event:',\n        _event,\n        'Session:',\n        session ? 'Exists' : 'null'\n      );\n\n      // Update session\n      setSession(session);\n\n      // Only update user if it's different to avoid triggering effects unnecessarily\n      const newUser = session?.user ?? null;\n      const newUserId = newUser?.id ?? null;\n      const currentUserId = user?.id ?? null;\n\n      // Skip state update if this is an INITIAL_SESSION event and we're already initialized with the same user\n      if (\n        _event === 'INITIAL_SESSION' &&\n        isInitialized.current &&\n        newUserId === initializedUser.current\n      ) {\n        console.log('[AuthContext] Skipping redundant user update for INITIAL_SESSION event');\n        return;\n      }\n\n      // Otherwise, update user if it's a real change\n      if (newUserId !== currentUserId) {\n        console.log(`[AuthContext] Updating user state from ${currentUserId} to ${newUserId}`);\n        setUser(newUser);\n\n        // If this is a signout, clear profile immediately\n        if (!newUser) {\n          setProfile(null);\n        }\n\n        // Track initialized user\n        initializedUser.current = newUserId;\n      }\n\n      setAuthError(null); // Clear error on auth change\n      setLoadingSession(false); // Session state is now known\n    });\n\n    return () => {\n      console.log('[AuthContext] Session Effect cleanup. Unsubscribing listener.');\n      ignore = true;\n      subscription?.unsubscribe();\n    };\n  }, []); // Runs only once on mount\n\n  // Update the fetchProfile function to handle missing table\n  const fetchProfile = async (userId: string) => {\n    console.log('[AuthContext] fetchProfile called for user:', userId);\n\n    if (!userId) {\n      console.log('[AuthContext] No userId provided to fetchProfile, returning null');\n      return null;\n    }\n\n    setLoadingProfile(true);\n\n    try {\n      console.log(\n        \"[AuthContext] fetchProfile: >>> Preparing to call supabase.from('profiles').select()\"\n      );\n      console.log(\n        '[AuthContext] fetchProfile: Inspecting supabase client object:',\n        getSupabaseClient().constructor.name\n      );\n      console.log(\n        '[AuthContext] fetchProfile: >>> Attempting Supabase query for profile of user:',\n        userId\n      );\n\n      // Try to fetch the profile\n      const { data, error, status } = await getSupabaseClient()\n        .from('profiles')\n        .select()\n        .eq('id', userId)\n        .single();\n\n      console.log(\n        '[AuthContext] fetchProfile: <<< Supabase query completed for user:',\n        userId,\n        'Status:',\n        status\n      );\n\n      // If the table doesn't exist or there's no profile, create a new one\n      if (\n        (error && status === 404) ||\n        (error && error.message?.includes('relation \"public.profiles\" does not exist')) ||\n        !data\n      ) {\n        console.log(\n          '[AuthContext] No profile found for user or profiles table does not exist. Creating profile directly...'\n        );\n\n        // Get user details from auth to create profile\n        const {\n          data: { user: currentUser },\n        } = await getSupabaseClient().auth.getUser();\n\n        if (currentUser) {\n          console.log('[AuthContext] Fetched current user for profile creation:', currentUser.id);\n\n          try {\n            // Create a new profile directly in the user's metadata\n            // This is a workaround since we can't create tables without admin rights\n            const { data: userMetadata, error: metadataError } =\n              await getSupabaseClient().auth.updateUser({\n                data: {\n                  name: currentUser.user_metadata?.name || '',\n                  role: currentUser.user_metadata?.role || 'client',\n                  is_profile_created: true,\n                },\n              });\n\n            if (metadataError) {\n              console.error('[AuthContext] Error updating user metadata:', metadataError);\n              return null;\n            }\n\n            // Create a virtual profile from the metadata\n            const profileFromMetadata = {\n              id: currentUser.id,\n              name: currentUser.user_metadata?.name || userMetadata.user.user_metadata?.name || '',\n              email: currentUser.email,\n              role:\n                currentUser.user_metadata?.role ||\n                userMetadata.user.user_metadata?.role ||\n                'client',\n              created_at: new Date().toISOString(),\n              updated_at: new Date().toISOString(),\n            };\n\n            console.log(\n              '[AuthContext] Created virtual profile from metadata:',\n              profileFromMetadata\n            );\n\n            // Update global profile state\n            setProfile(profileFromMetadata);\n            return profileFromMetadata;\n          } catch (metadataError) {\n            console.error('[AuthContext] Error in profile metadata update:', metadataError);\n            return null;\n          }\n        } else {\n          console.error('[AuthContext] Could not fetch current user for profile creation');\n          return null;\n        }\n      }\n\n      // If we get here, we successfully fetched an existing profile\n      console.log('[AuthContext] Profile successfully fetched:', data);\n      setProfile(data);\n      return data;\n    } catch (error) {\n      console.log('[AuthContext] Catch block error in fetchProfile:', error);\n      if (error instanceof AuthError) {\n        setAuthError(error);\n      } else {\n        console.log('[AuthContext] Non-AuthError during profile fetch:', error);\n      }\n      return null;\n    } finally {\n      console.log('[AuthContext] fetchProfile finally block for user:', userId);\n      setLoadingProfile(false);\n      console.log('[AuthContext] fetchProfile finished for user:', userId);\n    }\n  };\n\n  // NEW Effect for fetching profile when user changes\n  React.useEffect(() => {\n    let ignore = false;\n    console.log('[AuthContext] User Effect triggered. User:', user ? user.id : 'null');\n\n    if (user) {\n      console.log(`[AuthContext] User Effect: User found (${user.id}), attempting fetchProfile.`);\n      fetchProfile(user.id).catch((err) => {\n        // Catch errors specifically from the fetchProfile call initiated here\n        // Avoid setting state if component unmounted\n        if (!ignore) {\n          console.error('[AuthContext] User Effect: fetchProfile promise rejected:', err);\n          // Optionally set a specific error state here if needed\n          setAuthError(err instanceof AuthError ? err : null);\n          setLoadingProfile(false); // Ensure loading stops on error\n          // Clear the in-progress tracker if there was an error\n          profileFetchInProgress.current = null;\n        }\n      });\n    } else {\n      console.log(\n        '[AuthContext] User Effect: No user, clearing profile and stopping profile loading.'\n      );\n      setProfile(null); // Clear profile if user logs out\n      setLoadingProfile(false); // Ensure profile loading stops if there's no user\n      // Clear the in-progress tracker if there's no user\n      profileFetchInProgress.current = null;\n    }\n\n    return () => {\n      console.log('[AuthContext] User Effect cleanup.');\n      ignore = true;\n    };\n  }, [user]); // Dependency array includes user\n\n  // Explicitly type the signIn function\n  const signIn: AuthContextType['signIn'] = async ({ email, password }) => {\n    // setLoading(true); // Handled by listener/user effect\n    setAuthError(null);\n    try {\n      const { data, error } = await getSupabaseClient().auth.signInWithPassword({\n        email: email!, // Add non-null assertion or handle undefined\n        password: password!, // Add non-null assertion or handle undefined\n      });\n      if (error) throw error;\n      // onAuthStateChange will handle setting user and triggering profile fetch\n      return { data, error: null };\n    } catch (error) {\n      console.error('Login failed:', error as AuthError);\n      setAuthError(error as AuthError);\n      // setLoading(false); // Handled by listener/user effect\n      return { data: null, error: error as AuthError };\n    }\n  };\n\n  // Explicitly type the signUp function\n  const signUp: AuthContextType['signUp'] = async ({ email, password, options }) => {\n    // setLoading(true); // Handled by listener/user effect\n    setAuthError(null);\n    try {\n      // options can include { data: { name: 'Full Name' } } for metadata\n      const { data, error } = await getSupabaseClient().auth.signUp({\n        email: email!,\n        password: password!,\n        options,\n      });\n      if (error) throw error;\n      // If successful, onAuthStateChange handles setting user/session\n      // If email verification is required, user object might be returned but session will be null initially\n      return { data, error: null };\n    } catch (error) {\n      console.error('Signup failed:', error as AuthError);\n      setAuthError(error as AuthError);\n      // setLoading(false); // Handled by listener/user effect\n      return { data: null, error: error as AuthError };\n    }\n  };\n\n  // Explicitly type the signOut function\n  const signOut: AuthContextType['signOut'] = async () => {\n    // setLoading(true); // Handled by listener/user effect\n    setAuthError(null);\n    try {\n      const { error } = await getSupabaseClient().auth.signOut();\n      if (error) throw error; // onAuthStateChange will handle clearing user/session/profile\n    } catch (error) {\n      console.error('Sign out failed:', error as AuthError);\n      setAuthError(error as AuthError);\n      // setLoading(false); // Handled by listener/user effect\n    }\n  };\n\n  // Function to update user profile\n  const updateProfile = async (updates: Partial<UserProfile>) => {\n    if (!user) {\n      return { error: new Error('No user logged in') };\n    }\n\n    setIsUpdatingProfile(true);\n\n    try {\n      // Use the appropriate client based on availability\n      const client = getSupabaseClient();\n\n      const { data, error } = await client\n        .from('profiles')\n        .update(updates)\n        .eq('id', user.id)\n        .select('*')\n        .single();\n\n      if (error) {\n        console.error('[AuthContext] Error updating profile:', error);\n        return { error };\n      }\n\n      console.log('[AuthContext] Profile updated successfully', data);\n      setProfile(data as UserProfile);\n      return { data, error: null };\n    } catch (error) {\n      console.error('[AuthContext] Unexpected error updating profile:', error);\n      return {\n        error: error instanceof Error ? error : new Error('Unknown error updating profile'),\n      };\n    } finally {\n      setIsUpdatingProfile(false);\n    }\n  };\n\n  // Combine loading states for the context value\n  const combinedLoading = loadingSession || loadingProfile;\n\n  // Ensure the provided value matches AuthContextType\n  const value: AuthContextType = {\n    session,\n    user,\n    profile,\n    loading: combinedLoading, // Use combined loading state\n    authError,\n    signIn,\n    signUp,\n    signOut,\n    updateProfile,\n  };\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n};\n\n// Export the useAuth hook\nexport function useAuth(): AuthContextType {\n  const context = React.useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/hooks/use-mobile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/hooks/use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/lib/api.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":115,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3551,3554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3551,3554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":117,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3624,3627],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3624,3627],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3721,3724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3721,3724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3795,3798],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3795,3798],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Define AuthenticatedUser interface directly here\n// Ideally, share this type with the backend (e.g., via a shared package)\nexport interface AuthenticatedUser {\n  id: string;\n  email: string;\n  name: string | null;\n  role: string;\n}\n\n// Define the base URL for the backend API\n// Ensure this matches the port your backend server is running on (e.g., 3001)\n// Use import.meta.env for Vite environment variables\nconst API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/api';\n\n// Interface for the user object returned by login/me\n// Based on server/config/passport.ts AuthenticatedUser\n// We might need a more complete User type later based on Prisma schema for other endpoints\nexport type User = AuthenticatedUser;\n\n/**\n * Performs a fetch request to the API.\n * Handles common headers, base URL, and basic error handling.\n * Credentials ('include') are crucial for sending/receiving session cookies.\n */\nasync function apiFetch<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n  const url = `${API_BASE_URL}${endpoint}`;\n  const defaultHeaders: HeadersInit = {\n    'Content-Type': 'application/json',\n    Accept: 'application/json',\n  };\n\n  const config: RequestInit = {\n    ...options,\n    headers: {\n      ...defaultHeaders,\n      ...options.headers,\n    },\n    credentials: 'include', // Essential for session cookies!\n  };\n\n  try {\n    const response = await fetch(url, config);\n\n    // Handle non-JSON responses for logout etc.\n    const contentType = response.headers.get('content-type');\n    let data;\n    if (contentType && contentType.indexOf('application/json') !== -1) {\n      data = await response.json();\n    } else {\n      // Handle text or no content responses\n      const text = await response.text();\n      // For successful logout, we might just get a message\n      if (response.ok) {\n        // Try to parse if it looks like JSON, otherwise return message or null\n        try {\n          data = JSON.parse(text);\n        } catch {\n          data = { message: text || 'Success' };\n        }\n      } else {\n        // If error and not JSON, construct an error object\n        data = { message: text || `HTTP error ${response.status}` };\n      }\n    }\n\n    if (!response.ok) {\n      // Throw an error that includes the message from the API response if possible\n      throw new Error(data?.message || `HTTP error ${response.status}`);\n    }\n\n    return data as T;\n  } catch (error) {\n    console.error(`API fetch error for endpoint ${endpoint}:`, error);\n    // Re-throw the error so calling components can handle it\n    throw error;\n  }\n}\n\n// --- Auth API Calls ---\n\nexport const login = (credentials: { email: string; password: string }): Promise<User> => {\n  return apiFetch<User>('/auth/login', {\n    method: 'POST',\n    body: JSON.stringify(credentials),\n  });\n};\n\nexport const register = (userData: {\n  name?: string;\n  email: string;\n  password: string;\n  role?: string;\n}): Promise<{ message: string; user: User }> => {\n  return apiFetch<{ message: string; user: User }>('/auth/register', {\n    method: 'POST',\n    body: JSON.stringify(userData),\n  });\n};\n\nexport const logout = (): Promise<{ message: string }> => {\n  return apiFetch<{ message: string }>('/auth/logout', {\n    method: 'POST',\n  });\n};\n\nexport const getCurrentUser = (): Promise<User> => {\n  return apiFetch<User>('/auth/me', {\n    method: 'GET',\n  });\n};\n\n// --- Mock Session/Resource API Calls (Example) ---\n// We will use these later, pointing to the mock endpoints for now\n\nexport const getClientSessions = (): Promise<any[]> => {\n  // Replace 'any' with Session type later\n  return apiFetch<any[]>('/sessions/client', { method: 'GET' });\n};\n\nexport const getClientResources = (): Promise<any[]> => {\n  // Replace 'any' with Resource type later\n  return apiFetch<any[]>('/resources/client', { method: 'GET' });\n};\n\n// Add other API calls for sessions, resources, profile etc. as needed\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/lib/supabase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/lib/supabaseClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/lib/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/pages/Auth.tsx","messages":[],"suppressedMessages":[{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":352,"column":33,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[12808,12871],"text":"If you&apos;re using a VPN or firewall, try disabling it temporarily"},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[12808,12871],"text":"If you&lsquo;re using a VPN or firewall, try disabling it temporarily"},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[12808,12871],"text":"If you&#39;re using a VPN or firewall, try disabling it temporarily"},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[12808,12871],"text":"If you&rsquo;re using a VPN or firewall, try disabling it temporarily"},"desc":"Replace with `&rsquo;`."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/pages/Dashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/pages/Dashboard/ClientsPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1873,1876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1873,1876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\n// Use the consolidated Supabase client\nimport { supabase } from '../../lib/supabase';\n// Go up two levels to reach src directory\nimport { useAuth } from '../../contexts/AuthContext';\n\ninterface Client {\n  id: string;\n  full_name: string | null;\n  email: string;\n}\n\nconst ClientsPage: React.FC = () => {\n  const [clients, setClients] = useState<Client[]>([]);\n  const [loadingClients, setLoadingClients] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  const { profile, loading: authLoading } = useAuth(); // Use the real auth hook\n\n  useEffect(() => {\n    // Only fetch clients if auth is not loading and the user is a coach\n    if (!authLoading && profile?.role === 'coach') {\n      fetchClients();\n    } else if (!authLoading && profile?.role !== 'coach') {\n      // Should be handled by ProtectedRoute, but as a fallback:\n      setError('Access denied. Only coaches can view this page.');\n      setLoadingClients(false);\n    }\n    // If authLoading is true, we wait\n    // If profile is null (not logged in), ProtectedRoute handles it\n\n    async function fetchClients() {\n      try {\n        setLoadingClients(true);\n        setError(null);\n\n        // RLS policy ensures only clients linked to the logged-in coach (auth.uid()) are returned.\n        const { data, error: fetchError } = await supabase\n          .from('profiles')\n          .select('id, full_name, email')\n          .eq('role', 'client');\n\n        if (fetchError) {\n          // Handle specific Supabase errors if needed\n          if (fetchError.code === '42501') {\n            // RLS policy violation\n            setError('You do not have permission to view clients.');\n          } else {\n            throw fetchError;\n          }\n        } else {\n          setClients(data || []);\n        }\n      } catch (err: any) {\n        console.error('Error fetching clients:', err);\n        setError(err.message || 'Failed to fetch clients.');\n      } finally {\n        setLoadingClients(false);\n      }\n    }\n    // Dependency array includes authLoading and profile state\n  }, [authLoading, profile]);\n\n  // Show loading indicator while authentication is in progress\n  if (authLoading) {\n    return <div>Loading authentication...</div>;\n  }\n\n  // Show loading indicator while fetching clients\n  if (loadingClients) {\n    return <div>Loading clients...</div>;\n  }\n\n  // Show error message if any occurred\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error}</div>;\n  }\n\n  // We should only reach here if authenticated as a coach and clients are loaded\n  return (\n    <div>\n      <h1>My Clients</h1>\n      {clients.length === 0 ? (\n        <p>You don&apos;t have any clients assigned yet.</p>\n      ) : (\n        <ul>\n          {clients.map((client) => (\n            <li key={client.id}>\n              {client.full_name || 'Unnamed Client'} ({client.email})\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n};\n\nexport default ClientsPage;\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/pages/Debug.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/pages/Index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/pages/NotFound.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/pages/Profile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/pages/Sessions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/pages/Test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/supabaseClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/types.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[123,126],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[123,126],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements {\n      [elemName: string]: any;\n    }\n  }\n}\n\nexport {};\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/types/react-global.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[289,292],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[289,292],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[317,320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[317,320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[344,347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[344,347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[370,373],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[370,373],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[400,403],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[400,403],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[428,431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[428,431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[467,470],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[467,470],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[506,509],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[506,509],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[543,546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[543,546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[724,727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[724,727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// React global declarations for CI environment\n\ndeclare module 'react' {\n  export default any;\n  export * from 'react';\n}\n\ndeclare module 'react/jsx-runtime' {\n  export default any;\n  export * from 'react/jsx-runtime';\n}\n\ndeclare module 'react-router-dom' {\n  export const BrowserRouter: any;\n  export const Routes: any;\n  export const Route: any;\n  export const Link: any;\n  export const Navigate: any;\n  export const Outlet: any;\n  export const useNavigate: () => any;\n  export const useLocation: () => any;\n  export const useParams: () => any;\n}\n\ndeclare namespace JSX {\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  interface Element {}\n  interface IntrinsicElements {\n    [elemName: string]: any;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/src/vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/client/tailwind.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/config/passport.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/lib/error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/middleware/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/middleware/authMiddleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/migrate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/routes/admin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/routes/audio.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/routes/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/routes/clients.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/routes/resources.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/routes/sessions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/scripts/create-admin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/__tests__/auth.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/config/multer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1395,1398],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1395,1398],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1411,1414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1411,1414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1560,1563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1560,1563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import multer from 'multer';\nimport { S3Client } from '@aws-sdk/client-s3';\nimport multerS3 from 'multer-s3';\nimport { Request } from 'express';\n\n// Initialize S3 client if AWS credentials are provided\nconst s3Client =\n  process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY\n    ? new S3Client({\n        region: process.env.AWS_REGION || 'us-east-1',\n        credentials: {\n          accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n          secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n        },\n      })\n    : null;\n\n// File filter to accept only specific file types\nconst fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {\n  const allowedMimes = [\n    'image/jpeg',\n    'image/png',\n    'image/gif',\n    'application/pdf',\n    'audio/mpeg',\n    'audio/wav',\n    'audio/ogg',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  ];\n\n  if (allowedMimes.includes(file.mimetype)) {\n    cb(null, true);\n  } else {\n    cb(new Error('Invalid file type. Only images, PDFs, audio files, and documents are allowed.'));\n  }\n};\n\n// Configure storage based on environment\nconst storage = s3Client\n  ? multerS3({\n      s3: s3Client,\n      bucket: process.env.AWS_S3_BUCKET || 'satya-coaching-files',\n      metadata: (\n        req: Request,\n        file: Express.Multer.File,\n        cb: (error: any, metadata?: any) => void\n      ) => {\n        cb(null, { fieldName: file.fieldname });\n      },\n      key: (req: Request, file: Express.Multer.File, cb: (error: any, key?: string) => void) => {\n        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);\n        cb(null, `${file.fieldname}-${uniqueSuffix}`);\n      },\n    })\n  : multer.memoryStorage();\n\n// Create multer instance with configuration\nconst upload = multer({\n  storage,\n  fileFilter,\n  limits: {\n    fileSize: 10 * 1024 * 1024, // 10MB limit\n  },\n});\n\nexport default upload;\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/config/passport.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2430,2433],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2430,2433],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import passport from 'passport';\nimport { Strategy as LocalStrategy } from 'passport-local';\nimport scrypt from 'scrypt-js';\nimport { getUserByEmail, getUserById } from '../storage.js';\nimport { User } from '../models/User.js';\nimport { HydratedDocument } from 'mongoose';\n\n// Add these constants (should match the ones in storage.ts)\nconst SCRYPT_N = 16384;\nconst SCRYPT_r = 8;\nconst SCRYPT_p = 1;\nconst SCRYPT_dkLen = 64;\n\nexport function configurePassport() {\n  // Configure Local Strategy\n  passport.use(\n    new LocalStrategy(\n      {\n        usernameField: 'email',\n        passwordField: 'password',\n      },\n      async (email, password, done) => {\n        try {\n          console.log('[LocalStrategy] Attempting to authenticate user:', email);\n          const user = await getUserByEmail(email);\n\n          if (!user || !user.passwordSalt || !user.passwordHash) {\n            console.log('[LocalStrategy] User not found or missing password data:', email);\n            return done(null, false, { message: 'Incorrect email or password.' });\n          }\n\n          // Hash the provided password with the user's salt\n          console.log('[LocalStrategy] Hashing provided password for comparison');\n          const suppliedPasswordHashBuffer = await scrypt.scrypt(\n            Buffer.from(password),\n            Buffer.from(user.passwordSalt),\n            SCRYPT_N,\n            SCRYPT_r,\n            SCRYPT_p,\n            SCRYPT_dkLen\n          );\n\n          // Compare the hashes\n          const storedPasswordHashBuffer = Buffer.from(user.passwordHash, 'hex');\n          const isValid =\n            Buffer.compare(suppliedPasswordHashBuffer, storedPasswordHashBuffer) === 0;\n\n          if (!isValid) {\n            console.log('[LocalStrategy] Invalid password for user:', email);\n            return done(null, false, { message: 'Incorrect email or password.' });\n          }\n\n          console.log('[LocalStrategy] Authentication successful for user:', email);\n\n          // Remove sensitive data before passing to session\n          const userObject = user.toObject();\n          delete userObject.passwordHash;\n          delete userObject.passwordSalt;\n\n          return done(null, userObject);\n        } catch (error) {\n          console.error('[LocalStrategy] Error during authentication:', error);\n          return done(error);\n        }\n      }\n    )\n  );\n\n  // Configure serialization\n  passport.serializeUser((user: any, done) => {\n    console.log('[serializeUser] Serializing user:', user._id);\n    done(null, user._id);\n  });\n\n  // Configure deserialization\n  passport.deserializeUser(async (id: string, done) => {\n    console.log('[deserializeUser] Attempting to deserialize user with ID:', id);\n    try {\n      const user = await getUserById(id);\n      if (!user) {\n        console.error('[deserializeUser] User not found for ID:', id);\n        return done(null, false);\n      }\n\n      // Remove sensitive data before passing to session\n      const userObject = user.toObject();\n      delete userObject.passwordHash;\n      delete userObject.passwordSalt;\n\n      console.log('[deserializeUser] Successfully deserialized user:', id);\n      done(null, userObject);\n    } catch (error) {\n      console.error('[deserializeUser] Error deserializing user:', error);\n      done(error);\n    }\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/controllers/adminController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/controllers/analyticsController.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":229,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7156,7159],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7156,7159],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":290,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":290,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8858,8861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8858,8861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nexport const analyticsController = {\n  async getRevenue(req: Request, res: Response) {\n    try {\n      const { startDate, endDate } = req.query;\n      const payments = await prisma.payment.findMany({\n        where: {\n          createdAt: {\n            gte: startDate ? new Date(startDate as string) : undefined,\n            lte: endDate ? new Date(endDate as string) : undefined,\n          },\n          status: 'paid',\n        },\n        orderBy: {\n          createdAt: 'asc',\n        },\n      });\n\n      const revenueData = payments.reduce((acc: Record<string, number>, payment) => {\n        const date = payment.createdAt.toISOString().split('T')[0];\n        acc[date] = (acc[date] || 0) + payment.amount;\n        return acc;\n      }, {});\n\n      res.json(revenueData);\n    } catch (error) {\n      console.error('Error fetching revenue data:', error);\n      res.status(500).json({ message: 'Error fetching revenue data' });\n    }\n  },\n\n  async getUserGrowth(req: Request, res: Response) {\n    try {\n      const { startDate, endDate } = req.query;\n      const users = await prisma.user.findMany({\n        where: {\n          createdAt: {\n            gte: startDate ? new Date(startDate as string) : undefined,\n            lte: endDate ? new Date(endDate as string) : undefined,\n          },\n        },\n        orderBy: {\n          createdAt: 'asc',\n        },\n      });\n\n      const growthData = users.reduce((acc: Record<string, number>, user) => {\n        const date = user.createdAt.toISOString().split('T')[0];\n        acc[date] = (acc[date] || 0) + 1;\n        return acc;\n      }, {});\n\n      res.json(growthData);\n    } catch (error) {\n      console.error('Error fetching user growth data:', error);\n      res.status(500).json({ message: 'Error fetching user growth data' });\n    }\n  },\n\n  async getSessionMetrics(req: Request, res: Response) {\n    try {\n      const { startDate, endDate } = req.query;\n      const sessions = await prisma.session.findMany({\n        where: {\n          date: {\n            gte: startDate ? new Date(startDate as string) : undefined,\n            lte: endDate ? new Date(endDate as string) : undefined,\n          },\n        },\n        include: {\n          client: true,\n          coach: true,\n        },\n        orderBy: {\n          date: 'asc',\n        },\n      });\n\n      const metrics = {\n        totalSessions: sessions.length,\n        sessionsByStatus: sessions.reduce((acc: Record<string, number>, session) => {\n          acc[session.status] = (acc[session.status] || 0) + 1;\n          return acc;\n        }, {}),\n        sessionsByDate: sessions.reduce((acc: Record<string, number>, session) => {\n          const date = session.date.toISOString().split('T')[0];\n          acc[date] = (acc[date] || 0) + 1;\n          return acc;\n        }, {}),\n      };\n\n      res.json(metrics);\n    } catch (error) {\n      console.error('Error fetching session metrics:', error);\n      res.status(500).json({ message: 'Error fetching session metrics' });\n    }\n  },\n\n  async getCoachPerformance(req: Request, res: Response) {\n    try {\n      const { startDate, endDate } = req.query;\n      const coaches = await prisma.user.findMany({\n        where: {\n          role: 'coach',\n        },\n        include: {\n          coachSessions: {\n            where: {\n              date: {\n                gte: startDate ? new Date(startDate as string) : undefined,\n                lte: endDate ? new Date(endDate as string) : undefined,\n              },\n            },\n            include: {\n              client: true,\n            },\n          },\n        },\n      });\n\n      const performance = coaches.map((coach) => {\n        // Calculate unique clients\n        const clientIds = new Set(coach.coachSessions.map((session) => session.clientId));\n\n        return {\n          id: coach.id,\n          name: coach.name,\n          totalClients: clientIds.size, // Use size of Set for unique clients\n          totalSessions: coach.coachSessions.length, // Correctly uses coachSessions\n          sessionCompletionRate:\n            coach.coachSessions.filter((session) => session.status === 'completed').length /\n              coach.coachSessions.length || 0, // Correctly uses coachSessions\n        };\n      });\n\n      res.json(performance);\n    } catch (error) {\n      console.error('Error fetching coach performance data:', error);\n      res.status(500).json({ message: 'Error fetching coach performance data' });\n    }\n  },\n\n  /* // Commenting out function due to missing Session.title field\n  async getPopularTopics(req: Request, res: Response) {\n    try {\n      const { startDate, endDate } = req.query;\n      const sessions = await prisma.session.findMany({\n        where: {\n          date: {\n            gte: startDate ? new Date(startDate as string) : undefined,\n            lte: endDate ? new Date(endDate as string) : undefined\n          }\n        },\n        select: {\n          title: true // Error: title does not exist\n        }\n      });\n\n      const topics = sessions.reduce((acc: Record<string, number>, session) => {\n        const words = session.title.toLowerCase().split(' '); // Error: title does not exist\n        words.forEach(word => {\n          if (word.length > 3) { // Only count words longer than 3 characters\n            acc[word] = (acc[word] || 0) + 1;\n          }\n        });\n        return acc;\n      }, {});\n\n      const sortedTopics = Object.entries(topics)\n        .sort(([, a], [, b]) => b - a)\n        .slice(0, 10)\n        .reduce((acc: Record<string, number>, [key, value]) => {\n          acc[key] = value;\n          return acc;\n        }, {});\n\n      res.json(sortedTopics);\n    } catch (error) {\n      console.error('Error fetching popular topics:', error);\n      res.status(500).json({ message: 'Error fetching popular topics' });\n    }\n  },\n  */\n\n  async getPeakUsage(req: Request, res: Response) {\n    try {\n      const { startDate, endDate } = req.query;\n      const sessions = await prisma.session.findMany({\n        where: {\n          date: {\n            gte: startDate ? new Date(startDate as string) : undefined,\n            lte: endDate ? new Date(endDate as string) : undefined,\n          },\n        },\n        select: {\n          date: true,\n        },\n      });\n\n      const hourlyUsage = sessions.reduce((acc: Record<number, number>, session) => {\n        const hour = session.date.getHours();\n        acc[hour] = (acc[hour] || 0) + 1;\n        return acc;\n      }, {});\n\n      const dailyUsage = sessions.reduce((acc: Record<string, number>, session) => {\n        const day = session.date.getDay();\n        acc[day] = (acc[day] || 0) + 1;\n        return acc;\n      }, {});\n\n      res.json({\n        hourlyUsage,\n        dailyUsage,\n      });\n    } catch (error) {\n      console.error('Error fetching peak usage data:', error);\n      res.status(500).json({ message: 'Error fetching peak usage data' });\n    }\n  },\n\n  async exportData(req: Request, res: Response) {\n    try {\n      const { startDate, endDate, metrics } = req.body;\n      const data: Record<string, any> = {};\n\n      if (metrics.includes('revenue')) {\n        data.revenue = await prisma.payment.findMany({\n          where: {\n            createdAt: {\n              gte: startDate ? new Date(startDate) : undefined,\n              lte: endDate ? new Date(endDate) : undefined,\n            },\n            status: 'paid',\n          },\n          select: {\n            amount: true,\n            createdAt: true,\n          },\n        });\n      }\n\n      if (metrics.includes('sessions')) {\n        data.sessions = await prisma.session.findMany({\n          where: {\n            date: {\n              gte: startDate ? new Date(startDate) : undefined,\n              lte: endDate ? new Date(endDate) : undefined,\n            },\n          },\n          include: {\n            client: true,\n            coach: true,\n          },\n        });\n      }\n\n      if (metrics.includes('users')) {\n        data.users = await prisma.user.findMany({\n          where: {\n            createdAt: {\n              gte: startDate ? new Date(startDate) : undefined,\n              lte: endDate ? new Date(endDate) : undefined,\n            },\n          },\n          select: {\n            id: true,\n            name: true,\n            email: true,\n            role: true,\n            createdAt: true,\n          },\n        });\n      }\n\n      const csv = this.convertToCSV(data);\n      res.setHeader('Content-Type', 'text/csv');\n      res.setHeader('Content-Disposition', 'attachment; filename=analytics.csv');\n      res.send(csv);\n    } catch (error) {\n      console.error('Error exporting analytics data:', error);\n      res.status(500).json({ message: 'Error exporting analytics data' });\n    }\n  },\n\n  convertToCSV(data: Record<string, any>): string {\n    const headers: string[] = [];\n    const rows: string[][] = [];\n\n    // Extract headers and data from each metric\n    Object.entries(data).forEach(([metric, items]) => {\n      if (Array.isArray(items) && items.length > 0) {\n        const metricHeaders = Object.keys(items[0]).map((key) => `${metric}_${key}`);\n        headers.push(...metricHeaders);\n\n        items.forEach((item, index) => {\n          if (!rows[index]) rows[index] = [];\n          const values = Object.values(item);\n          rows[index].push(\n            ...values.map((value) =>\n              value instanceof Date\n                ? value.toISOString()\n                : typeof value === 'object'\n                  ? JSON.stringify(value)\n                  : String(value)\n            )\n          );\n        });\n      }\n    });\n\n    // Combine headers and rows into CSV format\n    const csvContent = [headers.join(','), ...rows.map((row) => row.join(','))].join('\\n');\n\n    return csvContent;\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/controllers/authController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/controllers/coachController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/controllers/coachNoteController.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2391,2394],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2391,2394],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3571,3574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3571,3574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4478,4481],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4478,4481],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":176,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5771,5774],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5771,5774],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\nimport { z } from 'zod';\nimport {\n  createCoachNote,\n  updateCoachNote,\n  getCoachNoteById,\n  getCoachNotesBySession,\n  getCoachNotesByCoach,\n  deleteCoachNote,\n  createCoachNoteSchema,\n  updateCoachNoteSchema,\n} from '../storage.js';\nimport { Session } from '../models/Session.js';\nimport { ICoachNote } from '../models/CoachNote.js';\n\nexport const coachNoteController = {\n  // Create a new coach note\n  async createCoachNote(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      if (req.user.role !== 'coach') {\n        return res.status(403).json({ error: 'Only coaches can create notes' });\n      }\n\n      const validatedData = createCoachNoteSchema.parse(req.body);\n\n      // Check if session exists and belongs to the coach\n      const session = await Session.findById(validatedData.sessionId);\n      if (!session) {\n        return res.status(404).json({ error: 'Session not found' });\n      }\n\n      if (session.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to create notes for this session' });\n      }\n\n      const coachNote = await createCoachNote(validatedData, req.user.id.toString());\n      res.status(201).json(coachNote);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        res.status(400).json({ error: error.errors });\n      } else {\n        console.error('Error creating coach note:', error);\n        res.status(500).json({ error: 'Failed to create coach note' });\n      }\n    }\n  },\n\n  // Get a coach note by ID\n  async getCoachNote(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const coachNote = await getCoachNoteById(req.params.id);\n\n      if (!coachNote) {\n        return res.status(404).json({ error: 'Coach note not found' });\n      }\n\n      // Check if user is authorized to view this note\n      if (coachNote.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to view this note' });\n      }\n\n      // Decrypt the text content if it's encrypted\n      if (coachNote.isEncrypted) {\n        const decryptedNote = coachNote.toObject();\n        decryptedNote.textContent = (coachNote as any).decryptText();\n        res.json(decryptedNote);\n      } else {\n        res.json(coachNote);\n      }\n    } catch (error) {\n      console.error('Error getting coach note:', error);\n      res.status(500).json({ error: 'Failed to get coach note' });\n    }\n  },\n\n  // Get all coach notes for a session\n  async getSessionCoachNotes(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const session = await Session.findById(req.params.sessionId);\n      if (!session) {\n        return res.status(404).json({ error: 'Session not found' });\n      }\n\n      // Check if user is authorized to view notes for this session\n      if (session.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to view notes for this session' });\n      }\n\n      const notes = await getCoachNotesBySession(req.params.sessionId);\n\n      // Decrypt all notes if they're encrypted\n      const decryptedNotes = notes.map((note) => {\n        const decryptedNote = note.toObject();\n        if (note.isEncrypted) {\n          decryptedNote.textContent = (note as any).decryptText();\n        }\n        return decryptedNote;\n      });\n\n      res.json(decryptedNotes);\n    } catch (error) {\n      console.error('Error getting session coach notes:', error);\n      res.status(500).json({ error: 'Failed to get coach notes' });\n    }\n  },\n\n  // Get all coach notes for the current coach\n  async getCoachNotes(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      if (req.user.role !== 'coach') {\n        return res.status(403).json({ error: 'Only coaches can view notes' });\n      }\n\n      const notes = await getCoachNotesByCoach(req.user.id.toString());\n\n      // Decrypt all notes if they're encrypted\n      const decryptedNotes = notes.map((note) => {\n        const decryptedNote = note.toObject();\n        if (note.isEncrypted) {\n          decryptedNote.textContent = (note as any).decryptText();\n        }\n        return decryptedNote;\n      });\n\n      res.json(decryptedNotes);\n    } catch (error) {\n      console.error('Error getting coach notes:', error);\n      res.status(500).json({ error: 'Failed to get coach notes' });\n    }\n  },\n\n  // Update a coach note\n  async updateCoachNote(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const coachNote = await getCoachNoteById(req.params.id);\n\n      if (!coachNote) {\n        return res.status(404).json({ error: 'Coach note not found' });\n      }\n\n      // Check if user is authorized to update this note\n      if (coachNote.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to update this note' });\n      }\n\n      const validatedData = updateCoachNoteSchema.parse(req.body);\n      const updatedNote = await updateCoachNote(req.params.id, validatedData);\n\n      if (!updatedNote) {\n        return res.status(404).json({ error: 'Coach note not found' });\n      }\n\n      // Decrypt the text content if it's encrypted\n      if (updatedNote.isEncrypted) {\n        const decryptedNote = updatedNote.toObject();\n        decryptedNote.textContent = (updatedNote as any).decryptText();\n        res.json(decryptedNote);\n      } else {\n        res.json(updatedNote);\n      }\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        res.status(400).json({ error: error.errors });\n      } else {\n        console.error('Error updating coach note:', error);\n        res.status(500).json({ error: 'Failed to update coach note' });\n      }\n    }\n  },\n\n  // Delete a coach note\n  async deleteCoachNote(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const coachNote = await getCoachNoteById(req.params.id);\n\n      if (!coachNote) {\n        return res.status(404).json({ error: 'Coach note not found' });\n      }\n\n      // Check if user is authorized to delete this note\n      if (coachNote.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to delete this note' });\n      }\n\n      await deleteCoachNote(req.params.id);\n      res.status(204).send();\n    } catch (error) {\n      console.error('Error deleting coach note:', error);\n      res.status(500).json({ error: 'Failed to delete coach note' });\n    }\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/controllers/fileController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/controllers/reflectionController.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3712,3715],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3712,3715],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":149,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5298,5301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5298,5301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":203,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7211,7214],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7211,7214],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":230,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8163,8166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8163,8166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\nimport { z } from 'zod';\nimport { IReflection, Reflection } from '../models/Reflection.js';\nimport { Session } from '../models/Session.js';\nimport { File } from '../models/File.js';\nimport mongoose from 'mongoose';\n\n// Validation schemas\nconst createReflectionSchema = z.object({\n  sessionId: z.string(),\n  textContent: z.string(),\n  audioFileId: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n});\n\nconst updateReflectionSchema = createReflectionSchema.partial();\n\nexport const reflectionController = {\n  // Create a new reflection\n  async createReflection(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const validatedData = createReflectionSchema.parse(req.body);\n\n      // Check if session exists and user has access\n      const session = await Session.findById(validatedData.sessionId);\n      if (!session) {\n        return res.status(404).json({ error: 'Session not found' });\n      }\n\n      if (session.clientId.toString() !== req.user.id.toString()) {\n        return res\n          .status(403)\n          .json({ error: 'Not authorized to create reflection for this session' });\n      }\n\n      // If audio file is provided, verify it exists and belongs to the user\n      if (validatedData.audioFileId) {\n        const audioFile = await File.findById(validatedData.audioFileId);\n        if (!audioFile || audioFile.userId.toString() !== req.user.id.toString()) {\n          return res.status(400).json({ error: 'Invalid audio file' });\n        }\n      }\n\n      const reflection = new Reflection({\n        ...validatedData,\n        userId: req.user.id,\n        sessionId: new mongoose.Types.ObjectId(validatedData.sessionId),\n        audioFileId: validatedData.audioFileId\n          ? new mongoose.Types.ObjectId(validatedData.audioFileId)\n          : undefined,\n        tags: validatedData.tags\n          ? validatedData.tags.map((id) => new mongoose.Types.ObjectId(id))\n          : undefined,\n      });\n\n      await reflection.save();\n      res.status(201).json(reflection);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        res.status(400).json({ error: error.errors });\n      } else {\n        console.error('Error creating reflection:', error);\n        res.status(500).json({ error: 'Failed to create reflection' });\n      }\n    }\n  },\n\n  // Get a reflection by ID\n  async getReflection(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const reflection = await Reflection.findById(req.params.id)\n        .populate('sessionId')\n        .populate('audioFileId')\n        .populate('tags');\n\n      if (!reflection) {\n        return res.status(404).json({ error: 'Reflection not found' });\n      }\n\n      // Check if user has access to this reflection\n      const session = await Session.findById(reflection.sessionId);\n      if (!session) {\n        return res.status(404).json({ error: 'Associated session not found' });\n      }\n\n      if (req.user.role === 'client' && reflection.userId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to view this reflection' });\n      }\n\n      if (req.user.role === 'coach' && session.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to view this reflection' });\n      }\n\n      // Decrypt the text content if it's encrypted\n      if (reflection.isEncrypted) {\n        const decryptedReflection = reflection.toObject();\n        decryptedReflection.textContent = (reflection as any).decryptText();\n        res.json(decryptedReflection);\n      } else {\n        res.json(reflection);\n      }\n    } catch (error) {\n      console.error('Error getting reflection:', error);\n      res.status(500).json({ error: 'Failed to get reflection' });\n    }\n  },\n\n  // Get all reflections for a session\n  async getSessionReflections(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const session = await Session.findById(req.params.sessionId);\n      if (!session) {\n        return res.status(404).json({ error: 'Session not found' });\n      }\n\n      // Check if user has access to this session\n      if (req.user.role === 'client' && session.clientId.toString() !== req.user.id.toString()) {\n        return res\n          .status(403)\n          .json({ error: 'Not authorized to view reflections for this session' });\n      }\n\n      if (req.user.role === 'coach' && session.coachId.toString() !== req.user.id.toString()) {\n        return res\n          .status(403)\n          .json({ error: 'Not authorized to view reflections for this session' });\n      }\n\n      const reflections = await Reflection.find({ sessionId: req.params.sessionId })\n        .populate('audioFileId')\n        .populate('tags');\n\n      // Decrypt all reflections if they're encrypted\n      const decryptedReflections = reflections.map((reflection) => {\n        const decryptedReflection = reflection.toObject();\n        if (reflection.isEncrypted) {\n          decryptedReflection.textContent = (reflection as any).decryptText();\n        }\n        return decryptedReflection;\n      });\n\n      res.json(decryptedReflections);\n    } catch (error) {\n      console.error('Error getting session reflections:', error);\n      res.status(500).json({ error: 'Failed to get session reflections' });\n    }\n  },\n\n  // Update a reflection\n  async updateReflection(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const reflection = await Reflection.findById(req.params.id);\n      if (!reflection) {\n        return res.status(404).json({ error: 'Reflection not found' });\n      }\n\n      // Check if user is authorized to update this reflection\n      if (reflection.userId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to update this reflection' });\n      }\n\n      const validatedData = updateReflectionSchema.parse(req.body);\n\n      // If session ID is being updated, check if the new session exists and user has access\n      if (validatedData.sessionId) {\n        const session = await Session.findById(validatedData.sessionId);\n        if (!session) {\n          return res.status(404).json({ error: 'Session not found' });\n        }\n\n        if (session.clientId.toString() !== req.user.id.toString()) {\n          return res\n            .status(403)\n            .json({ error: 'Not authorized to update reflection for this session' });\n        }\n      }\n\n      // If audio file is being updated, verify it exists and belongs to the user\n      if (validatedData.audioFileId) {\n        const audioFile = await File.findById(validatedData.audioFileId);\n        if (!audioFile || audioFile.userId.toString() !== req.user.id.toString()) {\n          return res.status(400).json({ error: 'Invalid audio file' });\n        }\n      }\n\n      // Update the reflection\n      const updateData: any = { ...validatedData };\n\n      if (validatedData.sessionId) {\n        updateData.sessionId = new mongoose.Types.ObjectId(validatedData.sessionId);\n      }\n\n      if (validatedData.audioFileId) {\n        updateData.audioFileId = new mongoose.Types.ObjectId(validatedData.audioFileId);\n      }\n\n      if (validatedData.tags) {\n        updateData.tags = validatedData.tags.map((id) => new mongoose.Types.ObjectId(id));\n      }\n\n      const updatedReflection = await Reflection.findByIdAndUpdate(req.params.id, updateData, {\n        new: true,\n      })\n        .populate('audioFileId')\n        .populate('tags');\n\n      if (!updatedReflection) {\n        return res.status(404).json({ error: 'Reflection not found' });\n      }\n\n      // Decrypt the text content if it's encrypted\n      if (updatedReflection.isEncrypted) {\n        const decryptedReflection = updatedReflection.toObject();\n        decryptedReflection.textContent = (updatedReflection as any).decryptText();\n        res.json(decryptedReflection);\n      } else {\n        res.json(updatedReflection);\n      }\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        res.status(400).json({ error: error.errors });\n      } else {\n        console.error('Error updating reflection:', error);\n        res.status(500).json({ error: 'Failed to update reflection' });\n      }\n    }\n  },\n\n  // Delete a reflection\n  async deleteReflection(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const reflection = await Reflection.findById(req.params.id);\n      if (!reflection) {\n        return res.status(404).json({ error: 'Reflection not found' });\n      }\n\n      // Check if user is authorized to delete this reflection\n      if (reflection.userId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to delete this reflection' });\n      }\n\n      await Reflection.findByIdAndDelete(req.params.id);\n      res.status(204).send();\n    } catch (error) {\n      console.error('Error deleting reflection:', error);\n      res.status(500).json({ error: 'Failed to delete reflection' });\n    }\n  },\n\n  // Share reflection with coach\n  async shareWithCoach(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const reflection = await Reflection.findById(req.params.id);\n      if (!reflection) {\n        return res.status(404).json({ error: 'Reflection not found' });\n      }\n\n      // Check if user is authorized to share this reflection\n      if (reflection.userId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to share this reflection' });\n      }\n\n      // Get the session to find the coach\n      const session = await Session.findById(reflection.sessionId);\n      if (!session) {\n        return res.status(404).json({ error: 'Associated session not found' });\n      }\n\n      // In a real implementation, you might want to notify the coach or update a status\n      // For now, we'll just return success\n      res.json({ message: 'Reflection shared with coach successfully' });\n    } catch (error) {\n      console.error('Error sharing reflection with coach:', error);\n      res.status(500).json({ error: 'Failed to share reflection with coach' });\n    }\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/controllers/resourceController.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1054,1057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1054,1057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\nimport { Resource } from '../models/Resource.js';\nimport { User, IUser } from '../models/User.js';\nimport mongoose from 'mongoose';\n\nexport const resourceController = {\n  // Create a new resource\n  async createResource(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const { title, description, fileId, tags } = req.body;\n\n      const resource = await Resource.create({\n        title,\n        description,\n        fileId,\n        coachId: req.user.id,\n        tags,\n        assignedClientIds: [],\n      });\n\n      res.status(201).json(resource);\n    } catch (error) {\n      console.error('Error creating resource:', error);\n      res.status(500).json({ error: 'Failed to create resource' });\n    }\n  },\n\n  // Get all resources\n  async getResources(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const query: any = {};\n\n      if (req.user.role === 'coach') {\n        query.coachId = req.user.id;\n      } else if (req.user.role === 'client') {\n        query.assignedClientIds = req.user.id;\n      }\n\n      const resources = await Resource.find(query)\n        .populate('fileId')\n        .populate('tags')\n        .sort({ createdAt: -1 });\n\n      res.json(resources);\n    } catch (error) {\n      console.error('Error getting resources:', error);\n      res.status(500).json({ error: 'Failed to get resources' });\n    }\n  },\n\n  // Get a specific resource\n  async getResource(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const resource = await Resource.findById(req.params.id).populate('fileId').populate('tags');\n\n      if (!resource) {\n        return res.status(404).json({ error: 'Resource not found' });\n      }\n\n      if (req.user.role === 'coach' && resource.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to view this resource' });\n      }\n\n      if (\n        req.user.role === 'client' &&\n        !resource.assignedClientIds.map((id) => id.toString()).includes(req.user.id)\n      ) {\n        return res.status(403).json({ error: 'Not authorized to view this resource' });\n      }\n\n      res.json(resource);\n    } catch (error) {\n      console.error('Error getting resource:', error);\n      res.status(500).json({ error: 'Failed to get resource' });\n    }\n  },\n\n  // Update a resource\n  async updateResource(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const resource = await Resource.findById(req.params.id);\n\n      if (!resource) {\n        return res.status(404).json({ error: 'Resource not found' });\n      }\n\n      if (resource.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to update this resource' });\n      }\n\n      const { title, description, fileId, tags } = req.body;\n\n      const updatedResource = await Resource.findByIdAndUpdate(\n        req.params.id,\n        {\n          title,\n          description,\n          fileId,\n          tags,\n        },\n        { new: true }\n      )\n        .populate('fileId')\n        .populate('tags');\n\n      res.json(updatedResource);\n    } catch (error) {\n      console.error('Error updating resource:', error);\n      res.status(500).json({ error: 'Failed to update resource' });\n    }\n  },\n\n  // Delete a resource\n  async deleteResource(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const resource = await Resource.findById(req.params.id);\n\n      if (!resource) {\n        return res.status(404).json({ error: 'Resource not found' });\n      }\n\n      if (resource.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to delete this resource' });\n      }\n\n      await Resource.findByIdAndDelete(req.params.id);\n\n      res.json({ message: 'Resource deleted successfully' });\n    } catch (error) {\n      console.error('Error deleting resource:', error);\n      res.status(500).json({ error: 'Failed to delete resource' });\n    }\n  },\n\n  // Assign resource to clients\n  async assignResource(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const resource = await Resource.findById(req.params.id);\n\n      if (!resource) {\n        return res.status(404).json({ error: 'Resource not found' });\n      }\n\n      if (resource.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to assign this resource' });\n      }\n\n      const { clientIds } = req.body;\n\n      if (\n        !Array.isArray(clientIds) ||\n        !clientIds.every((id) => mongoose.Types.ObjectId.isValid(id))\n      ) {\n        return res.status(400).json({ error: 'Invalid client IDs provided' });\n      }\n\n      const clients = await User.find({\n        _id: { $in: clientIds },\n        role: 'client',\n      });\n\n      if (clients.length !== clientIds.length) {\n        return res.status(400).json({ error: 'One or more client IDs are invalid or not clients' });\n      }\n\n      const updatedResource = await Resource.findByIdAndUpdate(\n        req.params.id,\n        { assignedClientIds: clientIds },\n        { new: true }\n      )\n        .populate('fileId')\n        .populate('tags');\n\n      res.json(updatedResource);\n    } catch (error) {\n      console.error('Error assigning resource:', error);\n      res.status(500).json({ error: 'Failed to assign resource' });\n    }\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/controllers/sessionController.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5107,5110],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5107,5110],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5965,5968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5965,5968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\nimport { z } from 'zod';\nimport {\n  createSession,\n  getSessionById,\n  getSessionsByCoachId,\n  getSessionsByClientId,\n  updateSession,\n  deleteSession,\n  createSessionSchema,\n  updateSessionSchema,\n} from '../storage.js';\nimport { Session } from '../models/Session.js';\nimport { User } from '../models/User.js';\nimport { IUser } from '../models/User.js';\nimport { getNumericUserId } from '../../utils';\n\nexport const sessionController = {\n  // Create a new session\n  async createSession(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const validatedData = createSessionSchema.parse({\n        ...req.body,\n        coachId: req.user.id,\n      });\n\n      const session = await createSession(validatedData);\n      res.status(201).json(session);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        res.status(400).json({ error: error.errors });\n      } else {\n        console.error('Error creating session:', error);\n        res.status(500).json({ error: 'Failed to create session' });\n      }\n    }\n  },\n\n  // Get a session by ID\n  async getSession(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const session = await getSessionById(req.params.id);\n\n      if (!session) {\n        return res.status(404).json({ error: 'Session not found' });\n      }\n\n      if (\n        req.user.role !== 'admin' &&\n        session.coachId.toString() !== req.user.id.toString() &&\n        session.clientId.toString() !== req.user.id.toString()\n      ) {\n        return res.status(403).json({ error: 'Not authorized to view this session' });\n      }\n\n      res.json(session);\n    } catch (error) {\n      console.error('Error fetching session:', error);\n      res.status(500).json({ error: 'Failed to fetch session' });\n    }\n  },\n\n  // Get all sessions for a coach\n  async getCoachSessions(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const userId = getNumericUserId(req);\n      const sessions = await getSessionsByCoachId(userId.toString());\n      res.json(sessions);\n    } catch (error) {\n      console.error('Error fetching coach sessions:', error);\n      res.status(500).json({ error: 'Failed to fetch coach sessions' });\n    }\n  },\n\n  // Get all sessions for a client\n  async getClientSessions(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const userId = getNumericUserId(req);\n      const sessions = await getSessionsByClientId(userId.toString());\n      res.json(sessions);\n    } catch (error) {\n      console.error('Error fetching client sessions:', error);\n      res.status(500).json({ error: 'Failed to fetch client sessions' });\n    }\n  },\n\n  // Update a session\n  async updateSession(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const sessionId = req.params.id;\n      const session = await Session.findById(sessionId);\n\n      if (!session) {\n        return res.status(404).json({ error: 'Session not found' });\n      }\n\n      if (req.user.role !== 'admin' && session.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to update this session' });\n      }\n\n      const validatedData = updateSessionSchema.parse(req.body);\n      const updatedSession = await updateSession(sessionId, validatedData);\n\n      res.json(updatedSession);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        res.status(400).json({ error: error.errors });\n      } else {\n        console.error('Error updating session:', error);\n        res.status(500).json({ error: 'Failed to update session' });\n      }\n    }\n  },\n\n  // Delete a session\n  async deleteSession(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const sessionId = req.params.id;\n      const session = await Session.findById(sessionId);\n\n      if (!session) {\n        return res.status(404).json({ error: 'Session not found' });\n      }\n\n      if (req.user.role !== 'admin' && session.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to delete this session' });\n      }\n\n      await deleteSession(sessionId);\n      res.json({ message: 'Session deleted successfully' });\n    } catch (error) {\n      console.error('Error deleting session:', error);\n      res.status(500).json({ error: 'Failed to delete session' });\n    }\n  },\n\n  // Get upcoming sessions\n  async getUpcomingSessions(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const now = new Date();\n      const query: any = {\n        dateTime: { $gte: now },\n        status: 'scheduled',\n      };\n\n      if (req.user.role === 'coach') {\n        query.coachId = req.user.id;\n      } else if (req.user.role === 'client') {\n        query.clientId = req.user.id;\n      }\n\n      const sessions = await Session.find(query)\n        .sort({ dateTime: 1 })\n        .populate('coachId', 'name email')\n        .populate('clientId', 'name email');\n\n      res.json(sessions);\n    } catch (error) {\n      console.error('Error fetching upcoming sessions:', error);\n      res.status(500).json({ error: 'Failed to fetch upcoming sessions' });\n    }\n  },\n\n  // Get past sessions\n  async getPastSessions(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const now = new Date();\n      const query: any = {\n        dateTime: { $lt: now },\n        status: { $in: ['completed', 'cancelled'] },\n      };\n\n      if (req.user.role === 'coach') {\n        query.coachId = req.user.id;\n      } else if (req.user.role === 'client') {\n        query.clientId = req.user.id;\n      }\n\n      const sessions = await Session.find(query)\n        .sort({ dateTime: -1 })\n        .populate('coachId', 'name email')\n        .populate('clientId', 'name email');\n\n      res.json(sessions);\n    } catch (error) {\n      console.error('Error fetching past sessions:', error);\n      res.status(500).json({ error: 'Failed to fetch past sessions' });\n    }\n  },\n\n  // Send reminder for a session\n  async sendReminder(req: Request, res: Response) {\n    try {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Not authenticated' });\n      }\n\n      const sessionId = req.params.id;\n      const session = await Session.findById(sessionId);\n\n      if (!session) {\n        return res.status(404).json({ error: 'Session not found' });\n      }\n\n      if (req.user.role !== 'admin' && session.coachId.toString() !== req.user.id.toString()) {\n        return res.status(403).json({ error: 'Not authorized to send reminders for this session' });\n      }\n\n      // Get client details\n      const client = await User.findById(session.clientId).select('name email');\n\n      if (!client) {\n        return res.status(404).json({ error: 'Client not found' });\n      }\n\n      // Log the reminder (in a real implementation, this would send an email)\n      console.log(\n        `Reminder triggered for session ${sessionId} with client ${client.name} (${client.email})`\n      );\n\n      // Update the session to mark that a reminder was sent\n      await Session.findByIdAndUpdate(sessionId, {\n        $set: { clientReflectionReminderSent: true },\n      });\n\n      res.json({ message: 'Reminder sent successfully' });\n    } catch (error) {\n      console.error('Error sending reminder:', error);\n      res.status(500).json({ error: 'Failed to send reminder' });\n    }\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/controllers/tagController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/controllers/userController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/adminAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/compression.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/correlation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/cors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/limit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/rateLimit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/rbac.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/requestId.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/requestLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/responseTime.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/sanitizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/security.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/timeout.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/upload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/middleware/validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/models/CoachNote.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/models/File.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/models/Reflection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/models/Resource.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/models/Session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/models/Tag.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/models/User.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/admin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/analytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/coach.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/coachNote.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/file.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/oauth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/reflection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/resources.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/tag.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/routes/user.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/server.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":74,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2192,2195],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2192,2195],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport mongoose from 'mongoose';\nimport cors from 'cors';\nimport session from 'express-session';\nimport passport from 'passport';\nimport { config } from 'dotenv';\nimport { configurePassport } from './config/passport.js';\nimport sessionRoutes from './routes/session.js';\nimport reflectionRoutes from './routes/reflection.js';\nimport authRoutes from './routes/auth.js';\nimport fileRoutes from './routes/file.js';\nimport tagRoutes from './routes/tag.js';\nimport coachNoteRoutes from './routes/coachNote.js';\nimport adminRoutes from './routes/admin.js';\nimport coachRoutes from './routes/coach.js';\nimport userRoutes from './routes/user.js';\nimport resourceRoutes from './routes/resources.js';\nimport oauthRoutes from './routes/oauth.js';\nimport analyticsRoutes from './routes/analytics.js';\n\nconfig();\n\nconst app = express();\n\n// Connect to MongoDB\nmongoose\n  .connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/lumea')\n  .then(() => console.log('Connected to MongoDB'))\n  .catch((err) => console.error('MongoDB connection error:', err));\n\n// Middleware\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(\n  cors({\n    origin: process.env.CLIENT_URL || 'http://localhost:3000',\n    credentials: true,\n  })\n);\n\n// Session configuration\napp.use(\n  session({\n    secret: process.env.SESSION_SECRET || 'your-secret-key',\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n      secure: process.env.NODE_ENV === 'production',\n      maxAge: 24 * 60 * 60 * 1000, // 24 hours\n    },\n  })\n);\n\n// Initialize Passport\napp.use(passport.initialize());\napp.use(passport.session());\nconfigurePassport();\n\n// Routes\napp.use('/api/auth', authRoutes);\napp.use('/api/sessions', sessionRoutes);\napp.use('/api/reflections', reflectionRoutes);\napp.use('/api/files', fileRoutes);\napp.use('/api/tags', tagRoutes);\napp.use('/api/coach-notes', coachNoteRoutes);\napp.use('/api/admin', adminRoutes);\napp.use('/api/coach', coachRoutes);\napp.use('/api/users', userRoutes);\napp.use('/api/resources', resourceRoutes);\napp.use('/api/oauth', oauthRoutes);\napp.use('/api/analytics', analyticsRoutes);\n\n// Error handling middleware\napp.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Something broke!' });\n});\n\nconst PORT = process.env.PORT || 5000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nexport default app;\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/services/email.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/services/emailService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/services/oauth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/services/reminderService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/services/sessionCounterService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/storage.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":283,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":283,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8610,8613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8610,8613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":301,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9166,9169],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9166,9169],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":355,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10777,10780],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10777,10780],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":483,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":483,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15452,15455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15452,15455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import mongoose, { HydratedDocument } from 'mongoose';\nimport { Session, ISession } from './models/Session.js';\nimport { z } from 'zod';\nimport { File, IFile } from './models/File.js';\nimport { User, IUser } from './models/User.js';\nimport { Tag, ITag } from './models/Tag.js';\nimport { CoachNote, ICoachNote } from './models/CoachNote.js';\nimport { Reflection, IReflection } from './models/Reflection.js';\nimport scrypt from 'scrypt-js';\nimport crypto from 'crypto';\n\n// Add these constants at the top of the file\nconst SCRYPT_N = 16384; // CPU/memory cost parameter\nconst SCRYPT_r = 8; // Block size parameter\nconst SCRYPT_p = 1; // Parallelization parameter\nconst SCRYPT_dkLen = 64; // Derived key length\n\n// Session schemas\nexport const createSessionSchema = z.object({\n  coachId: z.string(),\n  clientId: z.string(),\n  dateTime: z.string().datetime(),\n  duration: z.number().min(1),\n  status: z.enum(['scheduled', 'completed', 'cancelled', 'rescheduled']).default('scheduled'),\n  paymentStatus: z.enum(['pending', 'paid', 'overdue']).default('pending'),\n  isRecurring: z.boolean().default(false),\n  recurrenceRule: z.string().optional(),\n  recurrenceEndDate: z.string().datetime().optional(),\n});\n\nexport const updateSessionSchema = z.object({\n  dateTime: z.string().datetime().optional(),\n  duration: z.number().min(1).optional(),\n  status: z.enum(['scheduled', 'completed', 'cancelled', 'rescheduled']).optional(),\n  paymentStatus: z.enum(['pending', 'paid', 'overdue']).optional(),\n  isRecurring: z.boolean().optional(),\n  recurrenceRule: z.string().optional(),\n  recurrenceEndDate: z.string().datetime().optional(),\n});\n\n// Tag schemas\nexport const createTagSchema = z.object({\n  name: z.string().min(1),\n  color: z.string().optional(),\n  description: z.string().optional(),\n});\n\nexport const updateTagSchema = createTagSchema.partial();\n\n// Coach Note schemas\nexport const createCoachNoteSchema = z.object({\n  sessionId: z.string(),\n  textContent: z.string(),\n  audioFileId: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  isEncrypted: z.boolean().default(true),\n});\n\nexport const updateCoachNoteSchema = z.object({\n  textContent: z.string().optional(),\n  audioFileId: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  isEncrypted: z.boolean().optional(),\n});\n\n// Session storage functions\nexport async function createSession(data: z.infer<typeof createSessionSchema>): Promise<ISession> {\n  const session = new Session({\n    ...data,\n    coachId: new mongoose.Types.ObjectId(data.coachId),\n    clientId: new mongoose.Types.ObjectId(data.clientId),\n  });\n  return await session.save();\n}\n\nexport async function updateSession(\n  id: string,\n  data: z.infer<typeof updateSessionSchema>\n): Promise<ISession | null> {\n  return await Session.findByIdAndUpdate(id, data, { new: true });\n}\n\nexport async function getSessionById(id: string): Promise<ISession | null> {\n  return await Session.findById(id);\n}\n\nexport async function getSessionsByCoachId(coachId: string): Promise<ISession[]> {\n  return await Session.find({ coachId: new mongoose.Types.ObjectId(coachId) });\n}\n\nexport async function getSessionsByClientId(clientId: string): Promise<ISession[]> {\n  return await Session.find({ clientId: new mongoose.Types.ObjectId(clientId) });\n}\n\nexport async function deleteSession(id: string): Promise<boolean> {\n  const result = await Session.findByIdAndDelete(id);\n  return !!result;\n}\n\n// Tag storage functions\nexport async function createTag(\n  data: z.infer<typeof createTagSchema>,\n  userId: string\n): Promise<ITag> {\n  const tag = new Tag({\n    ...data,\n    createdBy: new mongoose.Types.ObjectId(userId),\n  });\n  return await tag.save();\n}\n\nexport async function updateTag(\n  id: string,\n  data: z.infer<typeof updateTagSchema>\n): Promise<ITag | null> {\n  return await Tag.findByIdAndUpdate(id, data, { new: true });\n}\n\nexport async function getTagById(id: string): Promise<ITag | null> {\n  return await Tag.findById(id);\n}\n\nexport async function getTagsByUser(userId: string): Promise<ITag[]> {\n  return await Tag.find({ createdBy: new mongoose.Types.ObjectId(userId) });\n}\n\nexport async function deleteTag(id: string): Promise<boolean> {\n  const result = await Tag.findByIdAndDelete(id);\n  return !!result;\n}\n\n// Coach Note storage functions\nexport async function createCoachNote(\n  data: z.infer<typeof createCoachNoteSchema>,\n  coachId: string\n): Promise<HydratedDocument<ICoachNote>> {\n  const coachNote = new CoachNote({\n    ...data,\n    coachId: new mongoose.Types.ObjectId(coachId),\n    sessionId: new mongoose.Types.ObjectId(data.sessionId),\n    tags: data.tags?.map((id) => new mongoose.Types.ObjectId(id)),\n  });\n  return await coachNote.save();\n}\n\nexport async function updateCoachNote(\n  id: string,\n  data: z.infer<typeof updateCoachNoteSchema>\n): Promise<HydratedDocument<ICoachNote> | null> {\n  const updateData = {\n    ...data,\n    tags: data.tags?.map((id) => new mongoose.Types.ObjectId(id)),\n  };\n  return await CoachNote.findByIdAndUpdate(id, updateData, { new: true });\n}\n\nexport async function getCoachNoteById(id: string): Promise<HydratedDocument<ICoachNote> | null> {\n  return await CoachNote.findById(id);\n}\n\nexport async function getCoachNotesBySession(\n  sessionId: string\n): Promise<HydratedDocument<ICoachNote>[]> {\n  return await CoachNote.find({ sessionId: new mongoose.Types.ObjectId(sessionId) });\n}\n\nexport async function getCoachNotesByCoach(\n  coachId: string\n): Promise<HydratedDocument<ICoachNote>[]> {\n  return await CoachNote.find({ coachId: new mongoose.Types.ObjectId(coachId) });\n}\n\nexport async function deleteCoachNote(id: string): Promise<boolean> {\n  const result = await CoachNote.findByIdAndDelete(id);\n  return !!result;\n}\n\n// File storage functions\nexport async function createFileRecord(\n  userId: string,\n  fileData: {\n    url: string;\n    filename: string;\n    mimetype: string;\n    size: number;\n    context?: 'profile' | 'resource' | 'audio_note';\n  }\n): Promise<IFile> {\n  const file = new File({\n    userId: new mongoose.Types.ObjectId(userId),\n    ...fileData,\n  });\n\n  return await file.save();\n}\n\nexport async function getFileById(fileId: string, userId: string): Promise<IFile | null> {\n  return await File.findOne({\n    _id: new mongoose.Types.ObjectId(fileId),\n    userId: new mongoose.Types.ObjectId(userId),\n  });\n}\n\nexport async function getFilesByUserAndContext(\n  userId: string,\n  context: 'profile' | 'resource' | 'audio_note'\n): Promise<IFile[]> {\n  return await File.find({\n    userId: new mongoose.Types.ObjectId(userId),\n    context,\n  });\n}\n\nexport async function deleteFileRecord(fileId: string, userId: string): Promise<boolean> {\n  const result = await File.findOneAndDelete({\n    _id: new mongoose.Types.ObjectId(fileId),\n    userId: new mongoose.Types.ObjectId(userId),\n  });\n\n  return !!result;\n}\n\nexport async function getUserByEmail(email: string): Promise<IUser | null> {\n  try {\n    console.log('[getUserByEmail] Fetching user with email:', email);\n    const user = await User.findOne({ email });\n    if (!user) {\n      console.log('[getUserByEmail] User not found for email:', email);\n      return null;\n    }\n    console.log('[getUserByEmail] Successfully found user:', user._id);\n    return user;\n  } catch (error) {\n    console.error('[getUserByEmail] Error fetching user:', error);\n    throw new Error('Failed to get user by email');\n  }\n}\n\nexport async function getUserById(id: string): Promise<IUser | null> {\n  try {\n    console.log('[getUserById] Fetching user with ID:', id);\n    const user = await User.findById(id);\n    if (!user) {\n      console.log('[getUserById] User not found for ID:', id);\n      return null;\n    }\n    console.log('[getUserById] Successfully found user:', id);\n    return user;\n  } catch (error) {\n    console.error('[getUserById] Error fetching user:', error);\n    throw new Error('Failed to get user by ID');\n  }\n}\n\nexport async function createUser({\n  name,\n  email,\n  password,\n  role,\n}: {\n  name: string;\n  email: string;\n  password: string;\n  role: 'client' | 'coach' | 'admin';\n}): Promise<IUser> {\n  try {\n    console.log('[createUser] Starting user creation for email:', email);\n\n    // Generate a unique salt\n    const salt = crypto.randomBytes(16).toString('hex');\n    console.log('[createUser] Generated unique salt');\n\n    // Hash the password with the unique salt\n    const hashBuffer = await scrypt.scrypt(\n      Buffer.from(password),\n      Buffer.from(salt),\n      SCRYPT_N,\n      SCRYPT_r,\n      SCRYPT_p,\n      SCRYPT_dkLen\n    );\n    // Convert scrypt result to Buffer before toString\n    const passwordHash = (hashBuffer as any).toString('hex'); // Force type to any\n\n    console.log('[createUser] Password hashed successfully');\n\n    const user = new User({\n      name,\n      email,\n      passwordHash,\n      passwordSalt: salt,\n      role,\n      status: role === 'coach' ? 'pending' : 'active', // Coaches need approval\n    });\n\n    console.log('[createUser] Saving user to database');\n    const savedUser = await user.save();\n    console.log('[createUser] User saved successfully:', savedUser._id);\n\n    // Remove sensitive data before returning\n    const userObjectForReturn: any = savedUser.toObject();\n    delete userObjectForReturn.passwordHash;\n    delete userObjectForReturn.passwordSalt;\n\n    return userObjectForReturn;\n  } catch (error) {\n    console.error('[createUser] Error creating user:', error);\n    throw new Error('Failed to create user');\n  }\n}\n\nexport async function setUserPasswordResetToken(\n  userId: string,\n  token: string,\n  expiryDate: Date\n): Promise<void> {\n  const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\n\n  await User.findByIdAndUpdate(userId, {\n    passwordResetToken: hashedToken,\n    passwordResetExpires: expiryDate,\n  });\n}\n\nexport async function findUserByPasswordResetToken(token: string): Promise<IUser | null> {\n  const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\n\n  return User.findOne({\n    passwordResetToken: hashedToken,\n    passwordResetExpires: { $gt: Date.now() },\n  });\n}\n\nexport async function clearUserPasswordResetToken(userId: string): Promise<void> {\n  await User.findByIdAndUpdate(userId, {\n    $unset: { passwordResetToken: 1, passwordResetExpires: 1 },\n  });\n}\n\nexport async function updateUserPassword(userId: string, newPassword: string): Promise<void> {\n  try {\n    // Generate a new unique salt\n    const salt = crypto.randomBytes(16).toString('hex');\n\n    // Hash the new password with the new salt\n    const hashBuffer = await scrypt.scrypt(\n      Buffer.from(newPassword),\n      Buffer.from(salt),\n      SCRYPT_N,\n      SCRYPT_r,\n      SCRYPT_p,\n      SCRYPT_dkLen\n    );\n    // Convert scrypt result to Buffer before toString\n    const passwordHash = (hashBuffer as any).toString('hex'); // Force type to any\n\n    await User.findByIdAndUpdate(userId, {\n      passwordHash,\n      passwordSalt: salt,\n    });\n  } catch (error) {\n    console.error('[updateUserPassword] Error updating password:', error);\n    throw new Error('Failed to update password');\n  }\n}\n\n// Reflection schemas\nexport const createReflectionSchema = z.object({\n  sessionId: z.string(),\n  textContent: z.string(),\n  audioFileId: z.string().optional(),\n});\n\nexport const updateReflectionSchema = createReflectionSchema.partial();\n\n// Reflection storage functions\nexport async function createReflection(\n  data: z.infer<typeof createReflectionSchema>,\n  userId: string\n): Promise<IReflection> {\n  try {\n    console.log('[createReflection] Starting reflection creation for session:', data.sessionId);\n\n    // Check if the session exists\n    const session = await Session.findById(data.sessionId);\n    if (!session) {\n      throw new Error('Session not found');\n    }\n\n    // Check if the user is authorized to create a reflection for this session\n    if (session.clientId.toString() !== userId && session.coachId.toString() !== userId) {\n      throw new Error('Not authorized to create a reflection for this session');\n    }\n\n    // Check if a reflection already exists for this session\n    const existingReflection = await Reflection.findOne({ sessionId: data.sessionId });\n    if (existingReflection) {\n      throw new Error('Reflection already exists for this session');\n    }\n\n    const reflection = new Reflection({\n      ...data,\n      sessionId: new mongoose.Types.ObjectId(data.sessionId),\n      userId: new mongoose.Types.ObjectId(userId),\n      audioFileId: data.audioFileId ? new mongoose.Types.ObjectId(data.audioFileId) : undefined,\n    });\n\n    console.log('[createReflection] Saving reflection to database');\n    const savedReflection = await reflection.save();\n    console.log('[createReflection] Reflection saved successfully:', savedReflection._id);\n\n    return savedReflection;\n  } catch (error) {\n    console.error('[createReflection] Error creating reflection:', error);\n    throw error;\n  }\n}\n\nexport async function getReflectionById(reflectionId: string): Promise<IReflection | null> {\n  try {\n    console.log('[getReflectionById] Fetching reflection with ID:', reflectionId);\n    const reflection = await Reflection.findById(reflectionId);\n    if (!reflection) {\n      console.log('[getReflectionById] Reflection not found for ID:', reflectionId);\n      return null;\n    }\n    console.log('[getReflectionById] Successfully found reflection:', reflectionId);\n    return reflection;\n  } catch (error) {\n    console.error('[getReflectionById] Error fetching reflection:', error);\n    throw new Error('Failed to get reflection by ID');\n  }\n}\n\nexport async function getReflectionBySessionId(sessionId: string): Promise<IReflection | null> {\n  try {\n    console.log('[getReflectionBySessionId] Fetching reflection for session:', sessionId);\n    const reflection = await Reflection.findOne({\n      sessionId: new mongoose.Types.ObjectId(sessionId),\n    });\n    if (!reflection) {\n      console.log('[getReflectionBySessionId] Reflection not found for session:', sessionId);\n      return null;\n    }\n    console.log('[getReflectionBySessionId] Successfully found reflection for session:', sessionId);\n    return reflection;\n  } catch (error) {\n    console.error('[getReflectionBySessionId] Error fetching reflection:', error);\n    throw new Error('Failed to get reflection by session ID');\n  }\n}\n\nexport async function getReflectionsByUserId(userId: string): Promise<IReflection[]> {\n  try {\n    console.log('[getReflectionsByUserId] Fetching reflections for user:', userId);\n    const reflections = await Reflection.find({ userId: new mongoose.Types.ObjectId(userId) });\n    console.log('[getReflectionsByUserId] Successfully found reflections for user:', userId);\n    return reflections;\n  } catch (error) {\n    console.error('[getReflectionsByUserId] Error fetching reflections:', error);\n    throw new Error('Failed to get reflections by user ID');\n  }\n}\n\nexport async function updateReflection(\n  reflectionId: string,\n  updateData: z.infer<typeof updateReflectionSchema>,\n  userId: string\n): Promise<IReflection | null> {\n  try {\n    console.log('[updateReflection] Updating reflection:', reflectionId);\n\n    const reflection = await Reflection.findById(reflectionId);\n    if (!reflection) {\n      throw new Error('Reflection not found');\n    }\n\n    // Check if the user is authorized to update this reflection\n    if (reflection.userId.toString() !== userId) {\n      throw new Error('Not authorized to update this reflection');\n    }\n\n    const update: any = { ...updateData };\n\n    if (updateData.sessionId) {\n      // Check if the session exists\n      const session = await Session.findById(updateData.sessionId);\n      if (!session) {\n        throw new Error('Session not found');\n      }\n\n      // Check if the user is authorized to update a reflection for this session\n      if (session.clientId.toString() !== userId && session.coachId.toString() !== userId) {\n        throw new Error('Not authorized to update a reflection for this session');\n      }\n\n      update.sessionId = new mongoose.Types.ObjectId(updateData.sessionId);\n    }\n\n    if (updateData.audioFileId) {\n      update.audioFileId = new mongoose.Types.ObjectId(updateData.audioFileId);\n    }\n\n    const updatedReflection = await Reflection.findByIdAndUpdate(reflectionId, update, {\n      new: true,\n    });\n\n    console.log('[updateReflection] Reflection updated successfully:', reflectionId);\n    return updatedReflection;\n  } catch (error) {\n    console.error('[updateReflection] Error updating reflection:', error);\n    throw error;\n  }\n}\n\nexport async function deleteReflection(reflectionId: string, userId: string): Promise<boolean> {\n  try {\n    console.log('[deleteReflection] Deleting reflection:', reflectionId);\n\n    const reflection = await Reflection.findById(reflectionId);\n    if (!reflection) {\n      throw new Error('Reflection not found');\n    }\n\n    // Check if the user is authorized to delete this reflection\n    if (reflection.userId.toString() !== userId) {\n      throw new Error('Not authorized to delete this reflection');\n    }\n\n    const result = await Reflection.findByIdAndDelete(reflectionId);\n    console.log('[deleteReflection] Reflection deleted successfully:', reflectionId);\n    return !!result;\n  } catch (error) {\n    console.error('[deleteReflection] Error deleting reflection:', error);\n    throw error;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/types/express.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/src/types/express/index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/types/declarations.d.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `` with ``","line":22,"column":2,"nodeType":null,"messageId":"replace","endLine":22,"endColumn":3,"fix":{"range":[589,590],"text":"\n"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"// Type declarations for the server\n\nimport { Request } from 'express';\n\n// Type for objects that can decrypt text\nexport interface Decryptable {\n  decryptText(): string;\n}\n\n// DB query type - a generic type for database query objects\nexport type DatabaseQuery = unknown;\n\n// This makes the TypeScript compiler happy for now\n// Later we can replace with proper types from the ORM\nexport type QueryBuilder = unknown;\n\n// Declare global types like these to help with typings\ndeclare global {\n  namespace Express {\n    // Express specific augmentations - already defined in express.d.ts\n  }\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/server/vite.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/shared/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/shared/types/payment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/shared/types/privacy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/shared/types/reflection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/shared/types/resource.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/shared/types/session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/shared/types/user.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/tailwind.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/tomergalansky/Desktop/SatyaCoaching/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
