/**
 * IndexedDB utility for storing and retrieving encryption keys and managing offline queue
 */

// Database name and version
const DB_NAME = 'SatyaCoachingDB';
const DB_VERSION = 1;

// Object store names
const KEY_STORE = 'encryptionKeys';
const QUEUE_STORE = 'offlineQueue';

// IndexedDB instance
let db: IDBDatabase | null = null;

/**
 * Initialize the IndexedDB database
 * @returns {Promise<void>}
 */
export async function initIndexedDB(): Promise<void> {
  if (db) {
    return;
  }

  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = (event) => {
      console.error('Error opening IndexedDB:', event);
      reject(new Error('Failed to open IndexedDB'));
    };

    request.onsuccess = (event) => {
      db = (event.target as IDBOpenDBRequest).result;
      resolve();
    };

    request.onupgradeneeded = (event) => {
      const database = (event.target as IDBOpenDBRequest).result;

      // Create object store for encryption keys if it doesn't exist
      if (!database.objectStoreNames.contains(KEY_STORE)) {
        database.createObjectStore(KEY_STORE, { keyPath: 'id' });
      }

      // Create object store for offline queue if it doesn't exist
      if (!database.objectStoreNames.contains(QUEUE_STORE)) {
        database.createObjectStore(QUEUE_STORE, { keyPath: 'id', autoIncrement: true });
      }
    };
  });
}

/**
 * Save an encryption key to IndexedDB
 * @param {string} id - Unique identifier for the key (e.g., reflectionId or sessionId)
 * @param {Uint8Array} key - The encryption key to store
 * @returns {Promise<void>}
 */
export async function saveEncryptionKey(id: string, key: Uint8Array): Promise<void> {
  await ensureDBInitialized();

  return new Promise((resolve, reject) => {
    const transaction = db!.transaction([KEY_STORE], 'readwrite');
    const store = transaction.objectStore(KEY_STORE);

    // Convert Uint8Array to Array for storage (IndexedDB can't store typed arrays directly)
    const keyArray = Array.from(key);

    const request = store.put({ id, key: keyArray });

    request.onerror = (event) => {
      console.error('Error saving encryption key:', event);
      reject(new Error('Failed to save encryption key'));
    };

    request.onsuccess = () => {
      resolve();
    };
  });
}

/**
 * Retrieve an encryption key from IndexedDB
 * @param {string} id - Unique identifier for the key
 * @returns {Promise<Uint8Array | null>} - The encryption key or null if not found
 */
export async function getEncryptionKey(id: string): Promise<Uint8Array | null> {
  await ensureDBInitialized();

  return new Promise((resolve, reject) => {
    const transaction = db!.transaction([KEY_STORE], 'readonly');
    const store = transaction.objectStore(KEY_STORE);
    const request = store.get(id);

    request.onerror = (event) => {
      console.error('Error retrieving encryption key:', event);
      reject(new Error('Failed to retrieve encryption key'));
    };

    request.onsuccess = (event) => {
      const result = (event.target as IDBRequest).result;
      if (result) {
        // Convert Array back to Uint8Array
        resolve(new Uint8Array(result.key));
      } else {
        resolve(null);
      }
    };
  });
}

/**
 * Interface for queue items
 */
export interface QueueItem {
  id?: number; // Auto-generated by IndexedDB
  url: string;
  method: string;
  body?: any;
  headers?: Record<string, string>;
  timestamp: number;
  reflectionId?: string;
}

/**
 * Add an item to the offline queue
 * @param {QueueItem} item - The queue item to add
 * @returns {Promise<number>} - The ID of the added item
 */
export async function addToOfflineQueue(item: QueueItem): Promise<number> {
  await ensureDBInitialized();

  return new Promise((resolve, reject) => {
    const transaction = db!.transaction([QUEUE_STORE], 'readwrite');
    const store = transaction.objectStore(QUEUE_STORE);

    // Ensure timestamp is set
    if (!item.timestamp) {
      item.timestamp = Date.now();
    }

    const request = store.add(item);

    request.onerror = (event) => {
      console.error('Error adding to offline queue:', event);
      reject(new Error('Failed to add to offline queue'));
    };

    request.onsuccess = (event) => {
      const id = (event.target as IDBRequest).result as number;
      resolve(id);
    };
  });
}

/**
 * Get all items in the offline queue
 * @returns {Promise<QueueItem[]>} - Array of queue items
 */
export async function getOfflineQueue(): Promise<QueueItem[]> {
  await ensureDBInitialized();

  return new Promise((resolve, reject) => {
    const transaction = db!.transaction([QUEUE_STORE], 'readonly');
    const store = transaction.objectStore(QUEUE_STORE);
    const request = store.getAll();

    request.onerror = (event) => {
      console.error('Error retrieving offline queue:', event);
      reject(new Error('Failed to retrieve offline queue'));
    };

    request.onsuccess = (event) => {
      const items = (event.target as IDBRequest).result as QueueItem[];
      resolve(items);
    };
  });
}

/**
 * Remove an item from the offline queue
 * @param {number} id - The ID of the item to remove
 * @returns {Promise<void>}
 */
export async function removeFromOfflineQueue(id: number): Promise<void> {
  await ensureDBInitialized();

  return new Promise((resolve, reject) => {
    const transaction = db!.transaction([QUEUE_STORE], 'readwrite');
    const store = transaction.objectStore(QUEUE_STORE);
    const request = store.delete(id);

    request.onerror = (event) => {
      console.error('Error removing from offline queue:', event);
      reject(new Error('Failed to remove from offline queue'));
    };

    request.onsuccess = () => {
      resolve();
    };
  });
}

/**
 * Ensure that the database is initialized
 * @private
 */
async function ensureDBInitialized(): Promise<void> {
  if (!db) {
    await initIndexedDB();
  }
}
